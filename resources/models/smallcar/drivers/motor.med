native function digitalWrite(pin: int, val:int);
native function analogWrite(pin: int, val:int 0..1);

typedef int -1023 .. 1023 init 0 as signedPWM;
typedef enum {forward, backward, rotate_left, rotate_right, stop} as action;

automaton <pinDirection:int, pinSpeed:int> engine (speed : in signedPWM) {
    transitions {
        !speed.reqRead -> speed.reqRead = true;
        speed.reqRead && speed.reqWrite -> {
            sync speed;
            if (speed.value > 0) {
                digitalWrite(pinDirection, 1);
                analogWrite(pinSpeed, speed.value);
            } else {
                digitalWrite(pinDirection, 0);
                analogWrite(pinSpeed, -speed.value);
            }
        }
    }
}

// todo use system to encapsulate them
automaton speeder (act: in action, motor_l, motor_r: out signedPWM) {
    transitions {
        (act.reqWrite != motor_l.reqWrite) -> {
            motor_l.reqWrite = act.reqWrite;
            motor_r.reqWrite = act.reqWrite;
        }

        ((motor_l.reqRead && motor_r.reqRead) != act.reqRead) -> act.reqRead = motor_l.reqRead && motor_r.reqRead;

        act.reqRead && act.reqWrite -> {
            sync act;
            if (act.value == forward) {
                motor_l.value = 5;
                motor_r.value = 5;
            } else if (act.value == backward) {

            } else if (act.value == stop) {
                motor_l.value = 0;
                motor_r.value = 0;
            }
        }
    }
}

automaton controller (act: out action) {
    transitions {
        !act.reqWrite -> act.reqWrite = true;
        act.reqRead -> {
            act.value = forward;
            sync act;
        }
    }
}

system testbench() {
    components {
        m1 : engine<8, 9>;
        m2 : engine<11, 10>;
        c  : controller;
    }

    connections {
        speeder(c.act, m1.speed, m2.speed);
    }
}