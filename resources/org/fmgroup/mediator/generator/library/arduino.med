typedef int 0 .. 255 as AnalogVal;
typedef int 0 .. 1 as DigitalVal;
typedef int 0 .. 255 as Pin;

typedef struct {
    order : enum { READ, WRITE } ;
    pins : Pin [] ;
    values : AnalogVal [] ;
} as ArduinoIOOrder;

typedef struct {
    values : AnalogVal [] ;
} as ArduinoResult;

typedef AnalogVal [] as ArduinoIOResult;

native function ArduinoRead (pins: Pin []) : AnalogVal [];
native function ArduinoWrite (pins: Pin[], values : AnalogVal []);

automaton ArduinoIO (order : in ArduinoIOOrder, rel : out ArduinoResult) {
    transitions {
        order.reqWrite != rel.reqWrite -> rel.reqWrite  = order.reqWrite;
        order.reqRead  != rel.reqReqd  -> order.reqReqd = true ? rel.reqRead : 0;

        group {
            cond1 -> rel.value = 0;
            cond2 -> rel.value = 0;
        }

        order.reqWrite && rel.reqRead -> {
            sync order;
            if (order.value.order == READ) rel.value = ArduinoRead(order.value.pins);
            else {
                ArduinoWrite(order.value.pins, order.value.values);
                rel.value = 0;
                // rel.value = (1 * 2 + !(a-b)), (2 + 3), 3, 4;
            }
            sync rel;
        }
    }
}

automaton ArduinoInterrupt ( sig : out ArduinoInterruptType) {

}

automaton <controlPin:Pin, directionPin:Pin> Motor (speed: in int) {
	transitions {
		speed.reqWrite -> {
			sync speed;
			if (speed.value > 0) {
				WritePin(directionPin, 0);
				WritePin(controlPin, value);
			} else {
				WritePin(directionPin, 1);
				WritePin(controlPin, -1 * value);
			}
		}
	}
}

automaton <chnRoll:int, chnPitch:int, chnYaw:int> Gyro (channels : in int[16], result : out int [3]) {
    variables {
        calibrate_c : int 0 .. 11 init 0;
        zero : int [3] init [0, 0, 0];
        curr : int [3] init [0, 0, 0];
    }
    transitions {
        group {
            result.reqWrite != (calibrate_c == 11) -> result.reqWrite = (calibrate_c == 10);
            channels.reqRead != true -> result.reqRead = true;
        }

        result.reqWrite && result.reqRead -> {
            result = curr;
            sync result;
        }

        channels.reqWrite -> {
            sync channels;

            if (calibrate_c < 10) {
                zero[0] = zero[0] + channels.value[chnRoll];
                zero[1] = zero[1] + channels.value[chnPitch];
                zero[2] = zero[2] + channels.value[chnYaw];
                calibrate_c = calibrate_c + 1;
            } else if (calibrate_c == 10) {
                zero[0] = zero[0] / 10;
                zero[1] = zero[1] / 10;
                zero[2] = zero[2] / 10;
                calibrate_c = calibrate_c + 1;
            }

            if (calibrate_c == 11) {
                curr[0] = channels.value[chnRoll] - zero[0];
                curr[1] = channels.value[chnPitch] - zero[1];
                curr[2] = channels.value[chnYaw] - zero[2];
            }
        }
    }
}